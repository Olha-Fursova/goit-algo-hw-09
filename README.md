## Розв’язання задачі видачі решти: greedy vs dynamic programming
# Опис задачі
Мета: реалізувати два підходи до визначення оптимального набору монет для видачі решти покупцеві з фіксованого набору номіналів: [50, 25, 10, 5, 2, 1].

Необхідно створити:

- find_coins_greedy(sum, coins): реалізація жадібного алгоритму.

- find_min_coins(sum, coins): реалізація алгоритму динамічного програмування.

## Жадібний алгоритм (find_coins_greedy)
# Ідея: завжди першою брати найбільшу з доступних монет, що не перевищує залишок суми.
# Переваги:

Простий і швидкий (O(n) для кількості номіналів).

Підходить, якщо монети "гармонізовані".

# Недоліки:

Не гарантує мінімальну кількість монет у загальному випадку.

## Алгоритм динамічного програмування (find_min_coins)
# Ідея: знаходити мінімальну кількість монет для кожної проміжної суми до цільової, зберігаючи ці значення у списку dp.

# Переваги:

Завжди знаходить оптимальне рішення.

Ефективний при складних наборах монет або коли важлива мінімізація кількості монет.

# Недоліки:

Споживає більше памʼяті (O(sum)).

Дещо повільніший для великих сум.


## Дослідження
Жадібний алгоритм працює швидко й ефективно, якщо номінали монет гармонізовані.

Алгоритм динамічного програмування забезпечує найменшу кількість монет, особливо корисний при довільних номіналах.

Обидва підходи мають своє місце залежно від контексту: швидкість чи точність. За результатами досліджень, обидва видають схожі результати з найоптимальнішим рішенням. 

Якщо пофантазувати та збільшити список з номіналами (наприклад, [90, 80, 70, 60, 65, 50, 25, 10, 5, 2, 1], що, звісно, нереалістично у задачі з монетами, але може бути необхідним у інших типах задач), то отримуємо вже різні результати:

{90: 1, 10: 2, 2: 1, 1: 1} 
{60: 1, 50: 1, 2: 1, 1: 1}

Дані результати показують, що у випадку з жадібним підходом ми отримуємо на одну монету більше в загальній кількості монет, ніж при динамічному підході. Це дає краще бачення ефективності роботи різних підходів за використанням більшого об'єму бази даних. 

Також, що цікавого для себе я відмітила, що якщо мати більшу кількість номіналів, але збільшити при цьому вхідну суму для обчислень, то результати обох методів синхронізуються і видають точно однакові результати. Це стосується і стандартного набору номіналів, зазначеного у завданні.

## Висновок
Тож, можна визначити, що за результатами моїх власних досліджень з використанням різних баз даних (монетами з різними номіналами, або звичайним масивом з набором різних значень) динамічний підхід виграє у швидкості пошуку оптимального рішення та часової складності.